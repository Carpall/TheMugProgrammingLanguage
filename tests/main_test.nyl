type Math {
  func add(a: i32, b: i32): i32 { a + b }
}

func b() {
  const Math = Math.add(10, 2)
}

/*pub enum AllocatorErr: err { size_is_zero }

pub type Allocator<T> {

  // fields

  data_with_refc: *(T, u64)
  deallocated: bool

  // static

  pub func create<T>(): AllocatorErr!Allocator<T> {
    return Allocator.create<T>(default<T>!())
  }

  pub func create<T>(value: T): AllocatorErr!Allocator<T> {
    const allocation = malloc(self.get_real_size()) as *(T, u64)
    (*allocation).item1 = value
    (*allocation).item2 = 1
    return new Allocator { data_with_refc: allocation }
  }

  // public

  pub func drop(self: Allocator) {
    if self.deallocated { return }
    
    mfree(self.data_with_refc, self.get_real_size())
    self.deallocated = true
  }

  pub func get_real_size(self: Allocator) { size<T>!() + size<u64>!() }

  // private

  func get_alloc(self: Allocator): T { (*self.data_with_refc).item1 }
  func dereference(self: Allocator) { if --(*self.data_with_refc).item2 == 0 { self.drop() } }
  func reference(self: Allocator) { (*self.data_with_refc).item2++ }

  func `*`(self: Allocator): T {
    if self.deallocated { panic!("dereferenced nil pointer") } else { get_alloc() }
  }

  func `=`(self: Allocator, allocator: Allocator): T { self.dereference() }           // assigned
  func `^`(self: Allocator): Allocator               { self.reference() get_alloc() } // passed
  func `~`(self: Allocator)                          { self.dereference() }           // out of scoped
}

func malloc(size: u64): unk
func mfree(ptr: unk, size: u64)

[test]
func test_allocate_defer_deallocate() {
  const ptr = Allocator.create<i32>()
  defer ptr.drop()

  print!("*ptr: {}", *ptr)
}

[test]
func test_allocate_implicit_deallocate() {
  const ptr = Allocator.create<i32>()

  print!("*ptr: {}", *ptr)
}*/