NEW TODOS

- remove default values in for loop and other
- add support for user defined operators (only for non-int based values)
- add path checker
- add pragmas' chekers
- add defer statement
- add doc comments for pub members
- fix bugs with eof
- add tuple types and 'new (,,)' for initialize them
- fix tests
- write tests for other compiler components
- fix crash when error's position is on different lines
- add implicit new operator with type inference 'new { }' and '[]', with context type
- fix '//' at the start of the line is not recognized as comment by the lexer
- consider changing generic parameters from '<>' to '[]'
- add check for uninitialized memory
- add optional parameters
- add varargs
- add arrays
- change is into a new ast node, not boolean
- reimplement generics in function calls in the parser, temporary disabled due to other ideas about their syntax design
- add compiler symbols and use them to get target int size
- add function prototypes
- fix constant int folding '2 * 3 * 3'
- fix constant bool folding '!true'
- add condition folding
- add import global statement
- design in compilation flags a way not to update the help message
- foreach
- attributes for function prototypes in mirfunctionprototype 'extern, noreturn'
- switch statement
- add strip option also for llvm means
- adding enum member with type infer '.member'
- move _currentCycle etc... to CurrentScope
- fix '(*x).x = 1'
- refactor parser
- implement floats
- add 'and or'
- uncover for cycle's scope
- emit negative number when IsNegative is true at enum member

OLD TODOS

- 'func some() !sometype', this will mean that the function must be catched also if there is no real error to catch -> 'some() catch { return }'
- calls that return an enum error can be also not catched if in return expression, where the return's scope owner is a function that returns the same enum error
- reference printing (ex. the function where there is the error)
- default initialization of array members
- try operator, at the begin of a call it stops the function's execution and return an error: make it with lowering 'try some()' -> 'some() catch e { return e }' (with !type 'return' without e)
- enum can be negatives
- fix lexer tests
- add support for multiline errors
- make built in functions under 'funcname<>!()' pattern
- remove the 'isbuiltinfunction' in 'callfunction' and add a pragma 'builtin' only for macros
- write a path checker to make sure all paths of a scope returns a value, also with hidden subscope buffers
- add 'static code evaluator' -> 'static if some comp-time evaluable expression {}', 'static if size<T>!() > 10 { error!("too big") }'
- replace the 'when' statement with 'static' block 'static if os == Os.Win32 {}', evaluated at compile time
- in 'recognizestatement' make a check for _buffer.HasValue to known if the statement must be converted to an expression and assigned to hidden allocation _buffer
- implement 'dyn' type
- add a raw pointer 'i32*', manged pointer '*i32'
- to fix references (at the moment they works as left values in assignment but not in expression because there's not coercion system, it is disabled since the coercion bugs calls)
- add i16
- add unsigned integers
- fix import
- add operator implementation for unary
- add tuples
- fix modifier with generic items
- remove 'declare' directive
- fix type recursion with pointers in structure
- write test for the parser using a decomposing the ast into a string expression and comparing it to the original -> test = "expr()" Assert(test == ExpectExpression(test).Rebuild())
- fix loadenumerror in emitter
- consider changing 'new [i32] { }' in '[]' and 'new Person { }' in 'Person { }', so consider using 'new' operator for heap allocations
- add warnings
- let use negative numbers in enum declarations (enum errors should have a custom based type 'err' to avoid use of negative enum errors' member, -1 is used as success)
- add variants -> 'type Var = (A | B | C)'
- add an ambiguity finder in 'callfunction' in local generator -> 'functionsmatched = new list()' instead of 'return function' -> 'func..ed.add(function)', 'if func..ed.count > 1 report()'
- add function pointer
- add 'in function ..' in errors
- alloc arrays on the stack instead of the heap
- fix <null>/10
- infer generic type in base-with methdods
- fix code pragma
- fix lexer errors using lexertests
- consider using boolean operator positions for 'as' operator
- add 'with' operator
- consider adding an intermediate phase between the irgenerator and the llvm interface -> irgenerator shouldn't comunicate with llvm anymore
- refactor 'or' and 'and' emit functions and 'ret'
- add constant globally
- implement a better constant overflow check
- add an option type to allow type recursion
- fix hidden buffer type infer with enum errors
- refactor local generator -> hide llvm references
- add a block for function return
- make the compile a multi pass compiler
- emit hidden instructions to save argv
- make impossible to change field of a constant
- start to work for debugger (break points with built in functions)
- replace when statement with built in functions
- make check for dupplicates in variant types
- evaluate at compile time fmt macro and throw errors for bad formattation
- implement arc
- implement destructors `~`
- fix export pragmas
- fix constant floats: llvmsharp does not expose any function for constant float creation
- expose builtin functions for function and type's infos -> 'const fn: FuncInfo! = fninfo!(main) const types: InternalCompilerType! = fn.param_types'
- add runtime checks
- implement for in 
- consider removing 'break' in catch blocks
- make cycles and other statement expression but not evaluable in scopes -> 'const result = for i: u8, i < 10, i++ { if i == 7 { i+10 break } }'
- add support for enums in or! and!
- cache the term in the switch expression
- add trait/interface