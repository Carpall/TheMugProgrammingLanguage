using LLVMSharp.Interop;
using Mug.Generator.TargetGenerators.C;
using Mug.Generator.IR;
using Mug.Tokenizer;
using Mug.Parser;
using Mug.Parser.AST;
using System;
using System.Diagnostics;
using System.IO;
using System.Linq;
using Mug.Generator.TargetGenerators.LLVM;
using System.Collections.Generic;
using Mug.Symbols;

namespace Mug.Compilation
{
    public class CompilationUnit : CompilerComponent
    {
        public static readonly string[] AllowedExtensions = new[] { ".mug", ".z" };

        public string[] Paths { get; }
        public List<(string Path, SymbolTable Symbols)> GlobalResources { get; }
        public string PathsFolderHead { get; }
        public bool IsMainUnit { get; }

        public CompilationUnit(bool isMainUnit, string outputFilename, string pathsFolderHead, List<(string, SymbolTable)> globalImportedModulePaths, CompilationFlags flags, params string[] paths) : base(new(outputFilename, null, flags))
        {
            IsMainUnit = isMainUnit;
            PathsFolderHead = pathsFolderHead;
            Paths = FixPathSlahes(paths);
            Tower.Unit = this;
            GlobalResources = globalImportedModulePaths;
        }

        public CompilationUnit(bool isMainUnit, string outputFilename, string pathsFolderHead, params string[] paths) : this(isMainUnit, outputFilename, pathsFolderHead, new(), null, paths)
        {
        }

        internal static string[] FixPathSlahes(params string[] paths)
        {
            for (int i = 0; i < paths.Length; i++)
                paths[i] = paths[i].Replace('/', '\\');

            return paths;
        }

        public void CompileLLVMIR(int optimizazioneLevel, string output, bool onlyBitcode, string optionalFlag)
        {
            var e = GenerateLLVMIR(out var llvmmodule);
            PrettyPrinter.PrintAlerts(e);

            if (!HasErrors())
                WriteLLVMModule(optimizazioneLevel, output, onlyBitcode, optionalFlag, llvmmodule);
        }

        public void CompileC(int optimizazioneLevel, string output, string optionalFlag)
        {
            var e = GenerateC(out var ccode);
            PrettyPrinter.PrintAlerts(e);

            if (!HasErrors())
                WriteCModule(optimizazioneLevel, output, optionalFlag, ccode);
        }

        private void WriteLLVMModule(
            int optimizazioneLevel, string output, bool onlyBitcode, string optionalArgs, LLVMModuleRef llvmmodule)
        {
            var bitcode = Path.ChangeExtension(Tower.OutputFilename, "bc");

            // deletes a possible file named in the same way as the result, to avoid bugs in the while under
            if (File.Exists(bitcode)) File.Delete(bitcode);
            if (File.Exists(output)) File.Delete(output);

            // writes the module to a file
            if (llvmmodule.WriteBitcodeToFile(bitcode) != 0)
                CompilationTower.Throw("Error writing to file");

            if (onlyBitcode) return;

            // the program goes in this keeps the program waiting until it finds the file containing the compiled program
            while (!File.Exists(bitcode) || File.Exists(output))
                ;

            // clang compiler
            CallCompilerFromShell($"clang", $"{bitcode} -o {output} {optionalArgs}", optimizazioneLevel);

            // deletes the bytecode file, now remains only the executable generated by clang
            if (File.Exists(bitcode)) File.Delete(bitcode);
        }

        private void WriteCModule(
            int optimizazioneLevel, string output, string optionalArgs, string ccode)
        {
            var cfile = GetTempCachePath();
            if (File.Exists(cfile)) File.Delete(cfile);

            File.WriteAllText(cfile, ccode);

            while (!File.Exists(cfile))
                ;

            output = Path.GetFullPath(output);
            CallCompilerFromShell($"gcc", $"{cfile} -o {output} {optionalArgs}", optimizazioneLevel);

            if (Tower.Flags.GetFlag<bool>(CompilationFlagKind.Strip))
                CallCompilerFromShell("strip", output);
        }

        private static string GetTempCachePath()
        {
            return Path.ChangeExtension(Path.GetTempFileName(), "c");
        }

        public bool HasErrors()
        {
            return Tower.HasErrors();
        }

        public static void CallCompilerFromShell(string compiler, string args, int optimizazioneLevel = 0)
        {
            var call = Process.Start(
                new ProcessStartInfo
                {
                    FileName = compiler,
                    Arguments = $"{(optimizazioneLevel > 0 ? $"-O{optimizazioneLevel}" : "")} {args}",
                    // invisible window
                    CreateNoWindow = true,
                    UseShellExecute = false,
                    ErrorDialog = false,
                    RedirectStandardInput = true,
                    RedirectStandardOutput = true,
                    RedirectStandardError = true,
                });

            call.WaitForExit();
            if (call.ExitCode != 0)
            {
                var output = call.StandardOutput.ReadToEnd();

                if (string.IsNullOrEmpty(output))
                    output = call.StandardError.ReadToEnd();

                CompilationTower.Throw($"External compiler: {output}");
            }
        }

        private void InternalGenerateAST()
        {
            foreach (var path in Paths)
            {
                if (!File.Exists(path))
                    CompilationTower.Throw($"Invalid path '{path}'");

                if (!AllowedExtensions.Contains(Path.GetExtension(path)))
                    continue;

                var subtower = new CompilationTower(path, this);
                (subtower.Lexer = new(Path.GetFileNameWithoutExtension(path), File.ReadAllText(path), subtower)).Tokenize();

                var head = subtower.Parser.Parse();

                Tower.Types.AddRange(subtower.Types);
                Tower.Parser.Module.Members.AddRange(head.Members);
                Tower.Diagnostic.AddRange(subtower.Diagnostic);
            }
        }

        private void InternalGenerateTAST()
        {
            InternalGenerateAST();
            Tower.TAST = Tower.Solver.Solve();
        }

        private void InternalGenerateMIR()
        {
            InternalGenerateTAST();
            Tower.MergeMIR(Tower.Generator.Generate());
        }

        private void InternalGenerateLLVMIR()
        {
            InternalGenerateMIR();
            if (!HasErrors())
                Tower.LLVMModule = (LLVMModuleRef)Tower.TargetGenerator.Lower();
        }

        private void InternalGenerateC()
        {
            InternalGenerateMIR();
            if (!HasErrors())
                Tower.CModule = (string)Tower.TargetGenerator.Lower();
        }

        private CompilationException GenerateCatched(Action action)
        {
            CompilationException result;

            try { action(); result = new(Tower.Diagnostic); }
            catch (CompilationException e) { result = e; }

            return result;
        }

        public CompilationException GenerateAST(out NamespaceNode head)
        {
            var result = GenerateCatched(InternalGenerateAST);
            head = Tower.AST;
            return result;
        }

        public CompilationException GenerateTAST(out NamespaceNode head)
        {
            var result = GenerateCatched(InternalGenerateTAST);
            head = Tower.TAST;
            return result;
        }

        public CompilationException GenerateIR(out MIR ir)
        {
            var result = GenerateCatched(InternalGenerateMIR);
            ir = Tower.MIRModule;
            return result;
        }

        public CompilationException GenerateLLVMIR(out LLVMModuleRef ir)
        {
            Tower.SetGenerator(new LLVMGenerator(Tower));

            var result = GenerateCatched(InternalGenerateLLVMIR);
            ir = Tower.LLVMModule;
            return result;
        }

        public CompilationException GenerateC(out string code)
        {
            Tower.SetGenerator(new CGenerator(Tower));
            var result = GenerateCatched(InternalGenerateC);
            code = Tower.CModule;
            return result;
        }
    }
}
