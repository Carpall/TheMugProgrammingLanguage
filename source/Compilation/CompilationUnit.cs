using LLVMSharp.Interop;
using Mug.Generator.IR;
using Mug.Models.Lexer;
using Mug.Models.Parser;
using Mug.Models.Parser.AST;
using System;
using System.Diagnostics;
using System.IO;
using System.Linq;

namespace Mug.Compilation
{
    public class CompilationUnit : MugComponent
    {
        public static readonly string[] AllowedExtensions = new[] { ".mug" };
        internal const string MainFileName = "main.mug";

        public bool FailedOpeningPath { get; } = false;
        private readonly string[] _paths;

        private static string ClangFilename
        {
            get
            {
                if (Environment.OSVersion.Platform == PlatformID.Win32NT)
                    return "C:/Program Files/LLVM/bin/clang.exe";
                else
                    return "/usr/bin/clang";
            }
        }

        private void InitializeLexer(string moduleName, string source)
        {
            Tower.ModuleName = moduleName;
            Tower.Lexer = new MugLexer(moduleName, source, Tower);
        }

        public CompilationUnit(string moduleName, string source) : base(new(null))
        {
            InitializeLexer(moduleName, source);
        }

        public CompilationUnit(object filenames) : base(new(null))
        {
            if (filenames is string s)
                InitializeLexer(Path.GetFileName(s), File.ReadAllText(s));
            else if (filenames is string[] a)
                _paths = a;
            else
                CompilationTower.Throw($"Internal error: unable to construct CompilationUnit with {filenames.GetType()}");
        }

        public CompilationUnit(string path, bool throwerror) : base(new(path))
        {
            if (!File.Exists(path))
            {
                if (throwerror)
                    CompilationTower.Throw($"Unable to open path: '{path}'");

                FailedOpeningPath = true;
            }
            else
            {
                CompilationTower.Todo("fix compilation unit");
                // IRGenerator = new(path, File.ReadAllText(path), isMainModule);
            }
        }

        public void Compile(int optimizazioneLevel, string output, bool onlyBitcode, string optionalFlag)
        {
            // generates the bytecode
            GenerateMIR();

            CompileModule(optimizazioneLevel, output, onlyBitcode, optionalFlag);
        }

        /// <summary>
        /// writes the llvm module to a file and calls the llvm compiler on it
        /// </summary>
        private void CompileModule(int optimizazioneLevel, string output, bool onlyBitcode, string optionalFlag)
        {
            /*writeFile(
                IRGenerator.Module,
                optimizazioneLevel,
                Path.ChangeExtension(IRGenerator.Parser.Lexer.ModuleName, "bc"),
                output,
                onlyBitcode,
                optionalFlag);

            static void nothing()
            {
                // called to avoid misunderstanding while reading the code
            }

            /// writes the bytecode to a file, calls clang on it and deletes the bytecode file
            static void writeFile(LLVMModuleRef module, int optimizazioneLevel, string bitcode, string output, bool onlyBitcode, string optionalFlag)
            {
                // deletes a possible file named in the same way as the result, to avoid bugs in the while under
                if (File.Exists(bitcode)) File.Delete(bitcode);
                if (File.Exists(output)) File.Delete(output);

                // writes the module to a file
                if (module.WriteBitcodeToFile(bitcode) != 0)
                    PrettyPrinter.Throw("Error writing to file");

                if (onlyBitcode) return;

                // the program goes in this keeps the program waiting until it finds the file containing the compiled program
                while (!File.Exists(bitcode) || File.Exists(output)) nothing();

                // clang compiler
                CallClang($"{bitcode} -o {output} {optionalFlag}", optimizazioneLevel);

                // deletes the bytecode file, now remains only the executable generated by clang
                if (File.Exists(bitcode)) File.Delete(bitcode);
            }*/
        }

        /*public static void CallClang(string command, int optimizazioneLevel)
        {
            // checks the clang execuatble exists
            if (!File.Exists(ClangFilename))
                PrettyPrinter.Throw($"Cannot find the clang executable at: '{ClangFilename}'");

            // call clang
            var clang = Process.Start(
                new ProcessStartInfo
                {
                    FileName = ClangFilename,
                    Arguments = $"-O{optimizazioneLevel} {command}",
                    // invisible window
                    CreateNoWindow = true,
                    UseShellExecute = false,
                    ErrorDialog = false,
                    RedirectStandardInput = true,
                    RedirectStandardOutput = true,
                    RedirectStandardError = true,
                });

            // the program will wait until clang works
            clang.WaitForExit();
            if (clang.ExitCode != 0)
            {
                var output = clang.StandardOutput.ReadToEnd();

                if (output == "")
                    output = clang.StandardError.ReadToEnd();

                PrettyPrinter.Throw($"External compiler: {output}");
            }
        }*/

        private void Parse()
        {
            if (_paths is not null)
                GeneratePaths();
            else
                Tower.Parser.Parse();
        }

        public NamespaceNode GenerateAST()
        {
            Tower.Lexer.Tokenize();
            Parse();

            return Tower.Parser.Module;
        }

        private void GeneratePaths()
        {
            var head = new NamespaceNode()
            {
                Name = Token.NewInfo(TokenKind.ConstantString, Path.GetFileName(Environment.CurrentDirectory)),
                Members = new()
            };

            foreach (var path in _paths)
            {
                // only mug files
                if (!AllowedExtensions.Contains(Path.GetExtension(path)))
                    continue;

                var unit = new CompilationUnit(path/*, Path.GetFileName(path) == MainFileName*/, true);
                head.Members.Nodes.AddRange(((NamespaceNode)unit.GenerateAST()).Members.Nodes);
            }

            CompilationTower.Todo("fix generatepaths()");
            /*IRGenerator._isMainModule = true;
            IRGenerator.Parser.Module = head;
            IRGenerator.Parser.Lexer = new MugLexer(head.Name.Value, "");*/
        }

        public NamespaceNode GenerateTAST()
        {
            GenerateAST();
            return Tower.Solver.Solve();
        }

        public MIR GenerateMIR()
        {
            GenerateTAST();
            return Tower.Generator.Generator();
        }
    }
}
