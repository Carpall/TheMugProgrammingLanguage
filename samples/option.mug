const undefined = import!("std").unsafe.undefined

pub const Option = fn(
  static T: type
): type {
  union {
    Some: T, None: void

    pub const is_some = fn(self: Option(T)): bool { self is Some }
    pub const is_none = fn(self: Option(T)): bool { self is None }

    pub const unwrap = fn(self: Option(T)): T {
      if self.is_none() {
        panic!("Unwrapped 'None'")
      }
      
      self.unsafe_unwrap()
    }

    pub const contains = fn(self: Option(T), value: T): bool {
      self.is_some() and self.unsafe_unwrap() == value
    }

    pub const expect = fn(self: Option(T), err: str): T {
      if self.is_none() {
        panic!("{}", err)
      }

      self.unsafe_unwrap()
    }

    pub const unwrap_or = fn(self: Option(T), or_value: T): T {
      if self.is_some() { self.unsafe_unwrap() } else { or_value }
    }

    pub const unsafe_unwrap = fn(self: Option(T)): T {
      self as Some
    }
  }
}

pub const Some = fn(value: ?): Option(?) {
  Option(typeof!(value)).Some(value)
}

pub const None = fn(): Option(?) {
  const caller_cntx_type = caller!().context_type
  
  if caller_cntx_type == auto_type!() or
     caller_cntx_type != typeinfo!(Option)
  {
    report!("Type notation needed")
    Option(i32).None()
  } else {
    Option(caller_cntx_type.get_base_element()).None()
  }
}

test "some" {
  let mut x = Some(10)
  x = Some(1)
  println!("x: ", x.unwrap())
}

test "none" {
  let x: Option(i32) = None()
  println!("x.is_none(): ", x.is_none())
}