const undefined = import!("std").unsafe.undefined

pub fn Option(
  static T: type
): type {
  union {
    Some: T, None: u8

    pub fn is_some(self: Option(T)): bool { self is Some }
    pub fn is_none(self: Option(T)): bool { self is None }

    pub fn unwrap(self: Option(T)): T {
      if self.is_none() {
        panic!("Unwrapped 'None'")
      }
      
      self.unsafe_unwrap()
    }

    pub fn contains(self: Option(T), value: T): bool {
      self.is_some() and self.unsafe_unwrap() == value
    }

    pub fn expect(self: Option(T), err: str): T {
      if self.is_none() {
        panic!("{}", err)
      }

      self.unsafe_unwrap()
    }

    pub fn unwrap_or(self: Option(T), or_value: T): T {
      if self.is_some() { self.unsafe_unwrap() } else { or_value }
    }

    pub fn unsafe_unwrap(self: Option(T)): T {
      self as Some
    }
  }
}

pub fn Some(value: untyped): Option(typeof!(value)) {
  Option(typeof!(value)).Some(value)
}

fn get_option_base_type(): type {
  const context_type = caller!().context_type

  if context_type.get_element_type() == bad_type!() or
    context_type != Option(context_type.get_element_type()) {
    report!("Needed type notation: Option(T)")
    i32
  } else {
    context_type.get_element_type()
  }
}

pub fn None(
  static optionType: type = static get_option_base_type()
): Option(optionType) {
  Option(optionType).None()
}

test "some" {
  let mut x = Some(10)
  x = Some(1)
  assert!(x.unwrap() == 1)
}

test "none" {
  let x: Option(i32) = None()
  assert!(x.is_none())
}

test "none explicit" {
  let x = None(i32)
  assert!(!x.is_some())
}

test "some contains" {
  let x = Some(1)
  assert!(x.contains(1))
}

test "some expect" {
  let x = Some(1)
  let y = x.expect("unwrapping 1")
}