const undefined = import!("std").unsafe.undefined

pub const Option = fn(
  static T: type
): type {
  union {
    Some: T, None: u8

    pub const is_some = fn(self: Option(T)): bool { self is Some }
    pub const is_none = fn(self: Option(T)): bool { self is None }

    pub const unwrap = fn(self: Option(T)): T {
      if self.is_none() {
        panic!("Unwrapped 'None'")
      }
      
      self.unsafe_unwrap()
    }

    pub const contains = fn(self: Option(T), value: T): bool {
      self.is_some() and self.unsafe_unwrap() == value
    }

    pub const expect = fn(self: Option(T), err: str): T {
      if self.is_none() {
        panic!("{}", err)
      }

      self.unsafe_unwrap()
    }

    pub const unwrap_or = fn(self: Option(T), or_value: T): T {
      if self.is_some() { self.unsafe_unwrap() } else { or_value }
    }

    pub const unsafe_unwrap = fn(self: Option(T)): T {
      self as Some
    }
  }
}

pub const Some = fn(value: untyped): Option(typeof!(value)) {
  Option(typeof!(value)).Some(value)
}

const get_option_base_type = fn(): type {
  const context_type = caller!().context_type

  if context_type.get_element_type() == bad_type!() or
    context_type != Option(context_type.get_element_type()) {
    report!("Needed type notation: Option(T)")
    i32
  } else {
    context_type.get_element_type()
  }
}

pub const None = fn(
  static optionType: type = static get_option_base_type()
): Option(optionType) {
  Option(optionType).None()
}

(. test .) const some = fn {
  let mut x = Some(10)
  x = Some(1)
  assert!(x.unwrap() == 1)
}

(. test .) const none = fn {
  let x: Option(i32) = None()
  assert!(x.is_none())
}

(. test .) const none_explicit = fn {
  let x = None(i32)
  assert!(!x.is_some())
}

(. test .) const some_contains = fn {
  let x = Some(1)
  assert!(x.contains(1))
}

(. test .) const some_expect = fn {
  let x = Some(1)
  let y = x.expect("unwrapping 1")
}